use super::math;

use super::io;
use super::io::IOError;

use super::io::fs;
use super::result::Result;

pub struct Color {
    b: u8;
    g: u8;
    r: u8;
    a: u8;

    pub fn new(r: i64, g: i64, b: i64, a: i64) Color {
        var color: Color = undefined;
        color.r = r as u8;
        color.g = g as u8;
        color.b = b as u8;
        color.a = a as u8;

        return color;
    }
}

/// Image with 8 bit RGBA encoding
pub struct Image {
    buf: *Color;
    width: u32;
    height: u32;
    size: u32;

    pub fn new(width: u32, height: u32) Image {
        var image: Image = undefined;
        image.size = width * height;
        image.buf = @malloc(@sizeof(image.buf.*) * image.size) as *Color;
        image.width = width;
        image.height = height;

        return image;
    }

    pub fn deinit(self: *const Image) void {
        @free(self.buf);
    }

    pub fn set_pixel(self: *const Image, color: Color, x: i64, y: i64) void {
        const index = y * self.width + x;
        self.buf[index] = color;
    }

    pub fn fill(self: *const Image, color: Color) void {
        self.fill_rect(color, 0 as u32, 0 as u32, self.width, self.height);
    }

    pub fn fill_rect(self: *const Image, color: Color, x: u32, y: u32, w: u32, h: u32) void {
        for (y.. y+h) |yi| {
            for (x.. x+w) |xi| {
                const index = yi * self.width + xi;
                if (index < self.size) self.buf[index] = color;
            }
        }
    }

    pub fn fill_rect_grad(self: *const Image, top_color: Color, bottom_color: Color, x: u32, y: u32, w: u32, h: u32) void {
        const height: f32 = h;
        for (y.. y+h) |yi| {
            const ratio = (yi - y) / height;
            const color = Color::new(
                (bottom_color.r + ratio * (top_color.r - bottom_color.r)) as i64,
                (bottom_color.g + ratio * (top_color.g - bottom_color.g)) as i64,
                (bottom_color.b + ratio * (top_color.b - bottom_color.b)) as i64,
                (bottom_color.a + ratio * (top_color.a - bottom_color.a)) as i64
            );

            for (x.. x+w) |xi| {
                const index = yi * self.width + xi;
                if (index < self.size) self.buf[index] = color;
            }
        }
    }

    pub fn export_bmp(self: *const Image, path: *const u8) Result<i64, IOError> {
        const file_result = fs::open_file(path);
        if (file_result.is_err()) {
            return Result::<i64, IOError>::new_err(file_result.unwrap_err());
        }

        const file_handle = file_result.unwrap_ok();

        ////// HEADER ///////
        const header_result = write_bmp_header(file_handle, self.width, self.height);
        if (header_result.is_err()) {
            @fclose(file_handle);
            @fdelete(path);
            return Result::<i64, IOError>::new_err(io::IOError::FailedToWrite);
        }
        const header_bytes_written = header_result.unwrap_ok();

        const data_bytes = self.size * 4 as u32;
        var data_bytes_written = 0;
        const write_success = @fwrite(file_handle, self.buf as *u8, data_bytes, &data_bytes_written);
        if (!write_success or data_bytes_written != data_bytes) {
            @fclose(file_handle);
            @fdelete(path);
            return Result::<i64, IOError>::new_err(io::IOError::FailedToWrite);
        }

        @fclose(file_handle);
        const bytes_written = header_bytes_written + data_bytes_written;
        return Result::<i64, IOError>::new_ok(bytes_written);
    }
}

pub fn write_bmp_header(file_handle: i64, width: u32, height: u32) Result<i64, IOError> {
    const info: [138]u8 = undefined;
    for (0.. @len(info), info) |_, ptr| {
        ptr.* = 0 as u8;
    }

    const image_raw_size = width * height * 4;
    const size = @len(info) + image_raw_size;

    // Magic number
    info[0] = 'B';
    info[1] = 'M';
    // Little endian file size
    info[2] = (size & 255) as u8;
    info[3] = ((size >> 8) & 255) as u8;
    info[4] = ((size >> 16) & 255) as u8;
    info[5] = ((size >> 24) & 255) as u8;
    // Skip unused 6-9
    // Image data size 10-13
    info[10] = 138 as u8;

    // DIB Header
    // Header size
    info[14] = 124 as u8;
    // Image width
    info[18] = (width & 255) as u8;
    info[19] = ((width >> 8) & 255) as u8;
    info[20] = ((width >> 16) & 255) as u8;
    info[21] = ((width >> 24) & 255) as u8;
    // Image height
    const height = -height;
    info[22] = (height & 255) as u8;
    info[23] = ((height >> 8) & 255) as u8;
    info[24] = ((height >> 16) & 255) as u8;
    info[25] = ((height >> 24) & 255) as u8;
    // Planes
    info[26] = 1 as u8;
    // Bits per pixel
    info[28] = 32 as u8;
    // Format 30-33
    info[30] = 3 as u8;
    // Image raw size
    info[34] = (image_raw_size & 255) as u8;
    info[35] = ((image_raw_size >> 8) & 255) as u8;
    info[36] = ((image_raw_size >> 16) & 255) as u8;
    info[37] = ((image_raw_size >> 24) & 255) as u8;
    // Horz print rez
    info[38] = 19 as u8;
    info[39] = 11 as u8;
    // Vert print rez
    info[42] = 19 as u8;
    info[43] = 11 as u8;
    // 46-49 Skip colors in palette
    // 50-53 Skip important colors
    // 54-57 Red mask
    info[56] = 255 as u8;
    // 58-61 Green mask
    info[59] = 255 as u8;
    // 62-65 Blue mask
    info[62] = 255 as u8;
    // 66-69 Alpha mask
    info[69] = 255 as u8;
    // sRGB color space
    info[70] = 'B';
    info[71] = 'G';
    info[72] = 'R';
    info[73] = 's'; 
    // 74-137 Skip xyz

    var header_bytes_written = 0;
    const write_success = @fwrite(file_handle, &info[0], @len(info), &header_bytes_written);
    if (!write_success or header_bytes_written != @len(info)) {
        return Result::<i64, IOError>::new_err(io::IOError::FailedToWrite);
    } else {
        return Result::<i64, IOError>::new_ok(header_bytes_written);
    }
}